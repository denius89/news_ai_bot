# telegram_bot/utils/formatters.py
from __future__ import annotations
from datetime import datetime
from html import escape

MAX_TG_LEN = 4000  # –±–µ–∑–æ–ø–∞—Å–Ω–∞—è –¥–ª–∏–Ω–∞ –¥–ª—è Telegram (—Ä–µ–∞–ª—å–Ω—ã–π –ª–∏–º–∏—Ç 4096)


def _clamp_tg(text: str, max_len: int = MAX_TG_LEN) -> str:
    """–û–±—Ä–µ–∑–∞–µ—Ç —Ç–µ–∫—Å—Ç –¥–æ –±–µ–∑–æ–ø–∞—Å–Ω–æ–π –¥–ª–∏–Ω—ã –¥–ª—è Telegram, –¥–æ–±–∞–≤–ª—è—è –º–Ω–æ–≥–æ—Ç–æ—á–∏–µ."""
    if len(text) <= max_len:
        return text
    return text[: max_len - 1] + "‚Ä¶"


def _fmt_dt(iso: str | None) -> str:
    """–ö—Ä–∞—Å–∏–≤–æ —Ñ–æ—Ä–º–∞—Ç–∏—Ä—É–µ—Ç ISO-datetime ‚Üí 'DD Mon YYYY, HH:MM' –∏–ª–∏ '‚Äî'."""
    if not iso:
        return "‚Äî"
    try:
        dt = datetime.fromisoformat(iso.replace("Z", "+00:00"))
        return dt.strftime("%d %b %Y, %H:%M")
    except Exception:
        return iso


def _metric_icons(cred: float, imp: float) -> tuple[str, str]:
    """–≠–º–æ–¥–∑–∏ –¥–ª—è –º–µ—Ç—Ä–∏–∫ (credibility, importance)."""
    cred_icon = "‚úÖ" if cred > 0.7 else "‚ö†Ô∏è" if cred > 0.4 else "‚ùå"
    imp_icon = "üî•" if imp > 0.7 else "‚ö°" if imp > 0.4 else "üí§"
    return cred_icon, imp_icon


def _short(text: str, n: int = 220) -> str:
    """–ö–æ—Ä–æ—Ç–∫–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ (–¥–ª—è —Å–Ω–∏–ø–ø–µ—Ç–∞)."""
    text = (text or "").strip()
    if len(text) <= n:
        return text
    return text[: n - 1] + "‚Ä¶"


def country_flag(code: str | None) -> str:
    """–ü—Ä–µ–æ–±—Ä–∞–∑—É–µ—Ç ISO-–∫–æ–¥ —Å—Ç—Ä–∞–Ω—ã –≤ —ç–º–æ–¥–∑–∏-—Ñ–ª–∞–≥."""
    if not code:
        return ""
    code = code.upper()
    if code == "EU":
        return "üá™üá∫"
    try:
        return "".join(chr(127397 + ord(c)) for c in code)
    except Exception:
        return code


# -------- –Ω–æ–≤–æ—Å—Ç–∏ --------


def format_news(news: list[dict], limit: int = 5, min_importance: float = 0.4) -> str:
    if not news:
        return "‚ö†Ô∏è No fresh news"

    filtered = [n for n in news if float(n.get("importance") or 0) >= float(min_importance)]
    if not filtered:
        return "‚ö†Ô∏è No important news today"

    lines = ["üì∞ <b>Top news</b>"]
    for i, item in enumerate(filtered[:limit], start=1):
        title_raw = (item.get("title") or item.get("source") or "Untitled").strip()
        title = escape(title_raw)
        link = item.get("link") or ""
        source = escape(item.get("source") or "‚Äî")
        published = _fmt_dt(item.get("published_at"))

        cred = float(item.get("credibility") or 0.0)
        imp = float(item.get("importance") or 0.0)
        cred_icon, imp_icon = _metric_icons(cred, imp)

        summary = _short(item.get("content") or item.get("summary") or "", 260)
        summary = escape(summary)

        title_line = f'<b>{i}. <a href="{escape(link)}">{title}</a></b>'

        if summary:
            lines.append(
                f"\n{title_line}\n"
                f"{source} ¬∑ {published}\n"
                f"{cred_icon} <b>Credibility:</b> {cred:.2f} ¬∑ "
                f"{imp_icon} <b>Importance:</b> {imp:.2f}\n"
                f"‚Äî {summary}"
            )
        else:
            lines.append(
                f"\n{title_line}\n"
                f"{source} ¬∑ {published}\n"
                f"{cred_icon} <b>Credibility:</b> {cred:.2f} ¬∑ "
                f"{imp_icon} <b>Importance:</b> {imp:.2f}"
            )

    return _clamp_tg("\n".join(lines))


# -------- —Å–æ–±—ã—Ç–∏—è --------


def format_events(events: list[dict], limit: int = 5) -> str:
    """
    –°–ø–∏—Å–æ–∫ –±–ª–∏–∂–∞–π—à–∏—Ö —Å–æ–±—ã—Ç–∏–π (HTML) —Å category-specific —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ–º.

    –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –æ–ø—Ä–µ–¥–µ–ª—è–µ—Ç –∫–∞—Ç–µ–≥–æ—Ä–∏—é —Å–æ–±—ã—Ç–∏—è –∏ –ø—Ä–∏–º–µ–Ω—è–µ—Ç
    —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–∏–π —Ñ–æ—Ä–º–∞—Ç—Ç–µ—Ä –¥–ª—è –∫—Ä–∞—Å–∏–≤–æ–≥–æ –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è.

    Args:
        events: –°–ø–∏—Å–æ–∫ —Å–æ–±—ã—Ç–∏–π (dict —Å –ø–æ–ª—è–º–∏ category, subcategory, metadata)
        limit: –ú–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å–æ–±—ã—Ç–∏–π –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è

    Returns:
        –û—Ç—Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–Ω–∞—è HTML-—Å—Ç—Ä–æ–∫–∞ –¥–ª—è Telegram
    """
    if not events:
        return "‚ö†Ô∏è –ù–µ—Ç —Å–≤–µ–∂–∏—Ö —Å–æ–±—ã—Ç–∏–π"

    lines = ["üìÖ <b>–ü—Ä–µ–¥—Å—Ç–æ—è—â–∏–µ —Å–æ–±—ã—Ç–∏—è</b>"]

    for i, event in enumerate(events[:limit], start=1):
        category = event.get("category", "").lower()
        subcategory = event.get("subcategory", "").lower()

        # Category + subcategory routing
        if category == "sports":
            # Esports subcategories
            if subcategory in [
                "dota2",
                "csgo",
                "lol",
                "valorant",
                "pubg",
                "overwatch",
                "fifa_esports",
                "rocket_league",
                "starcraft",
                "esports_general",
            ]:
                text = format_event_esports(event)
            else:
                # Traditional sports
                text = format_event_sports(event)

        elif category == "crypto":
            text = format_event_crypto(event)

        elif category == "tech":
            text = format_event_tech(event)

        elif category == "markets":
            text = format_event_markets(event)

        elif category == "world":
            text = format_event_world(event)

        else:
            # Fallback –¥–ª—è legacy —Å–æ–±—ã—Ç–∏–π –∏–ª–∏ –Ω–µ–∏–∑–≤–µ—Å—Ç–Ω—ã—Ö –∫–∞—Ç–µ–≥–æ—Ä–∏–π
            text = format_event_generic(event)

        lines.append(f"\n<b>{i}.</b> {text}")

    return _clamp_tg("\n".join(lines))


# -------- Category-specific event formatters --------


def format_event_sports(event: dict) -> str:
    """
    –§–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ —Ç—Ä–∞–¥–∏—Ü–∏–æ–Ω–Ω—ã—Ö —Å–ø–æ—Ä—Ç–∏–≤–Ω—ã—Ö —Å–æ–±—ã—Ç–∏–π.

    Args:
        event: Event dictionary —Å metadata

    Returns:
        Formatted event string –¥–ª—è Telegram
    """
    metadata = event.get("metadata", {})
    subcategory = event.get("subcategory", "general")

    # –§—É—Ç–±–æ–ª
    if subcategory == "football":
        home = metadata.get("home_team", "")
        away = metadata.get("away_team", "")
        competition = metadata.get("competition", "")
        matchday = metadata.get("matchday", "")
        status = metadata.get("status", "Scheduled")

        title_text = f"{home} vs {away}" if home and away else event.get("title", "")
        comp_text = competition if competition else ""
        matchday_text = f" ‚Ä¢ Matchday {matchday}" if matchday else ""

        return (
            f"‚öΩ <b>{escape(title_text)}</b>\n"
            f"üèÜ {escape(comp_text)}{matchday_text}\n"
            f"üìÖ {_fmt_dt(event.get('starts_at'))}\n"
            f"‚ö° Status: {escape(status)}"
        )

    # –ë–∞—Å–∫–µ—Ç–±–æ–ª
    elif subcategory == "basketball":
        home = metadata.get("home_team", "")
        away = metadata.get("away_team", "")
        league = metadata.get("league", metadata.get("competition", ""))

        title_text = f"{home} vs {away}" if home and away else event.get("title", "")

        return f"üèÄ <b>{escape(title_text)}</b>\n" f"üèÜ {escape(league)}\n" f"üìÖ {_fmt_dt(event.get('starts_at'))}"

    # –•–æ–∫–∫–µ–π
    elif subcategory == "hockey":
        home = metadata.get("home_team", "")
        away = metadata.get("away_team", "")
        league = metadata.get("league", metadata.get("competition", ""))

        title_text = f"{home} vs {away}" if home and away else event.get("title", "")

        return f"üèí <b>{escape(title_text)}</b>\n" f"üèÜ {escape(league)}\n" f"üìÖ {_fmt_dt(event.get('starts_at'))}"

    # –û–±—â–∏–π —Ñ–æ—Ä–º–∞—Ç –¥–ª—è –¥—Ä—É–≥–∏—Ö –≤–∏–¥–æ–≤ —Å–ø–æ—Ä—Ç–∞
    else:
        return (
            f"üèÜ <b>{escape(event.get('title', ''))}</b>\n"
            f"üìÖ {_fmt_dt(event.get('starts_at'))}\n"
            f"üìç {escape(event.get('location', ''))}"
            if event.get("location")
            else ""
        )


def format_event_esports(event: dict) -> str:
    """
    –§–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –∫–∏–±–µ—Ä—Å–ø–æ—Ä—Ç–∏–≤–Ω—ã—Ö —Å–æ–±—ã—Ç–∏–π.

    Args:
        event: Event dictionary —Å metadata

    Returns:
        Formatted event string –¥–ª—è Telegram
    """
    metadata = event.get("metadata", {})
    subcategory = event.get("subcategory", "esports_general")

    team1 = metadata.get("team1", metadata.get("home_team", ""))
    team2 = metadata.get("team2", metadata.get("away_team", ""))
    tournament = metadata.get("tournament", metadata.get("competition", ""))
    game = metadata.get("game", subcategory.upper())
    format_type = metadata.get("format", "BO3")

    # Game-specific icons
    game_icons = {
        "dota2": "üêâ",
        "csgo": "üî´",
        "lol": "‚öîÔ∏è",
        "valorant": "üéØ",
        "pubg": "üéÆ",
        "overwatch": "üéÆ",
        "starcraft": "üéÆ",
    }
    icon = game_icons.get(subcategory, "üéÆ")

    title_text = f"{team1} vs {team2}" if team1 and team2 else event.get("title", "")

    lines = [
        f"{icon} <b>{escape(title_text)}</b>",
        f"üèÜ {escape(tournament)} ({escape(game)})",
        f"üìÖ {_fmt_dt(event.get('starts_at'))}",
    ]

    if format_type:
        lines.append(f"‚öîÔ∏è Format: {escape(format_type)}")

    return "\n".join(lines)


def format_event_crypto(event: dict) -> str:
    """
    –§–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –∫—Ä–∏–ø—Ç–æ–≤–∞–ª—é—Ç–Ω—ã—Ö —Å–æ–±—ã—Ç–∏–π.

    Args:
        event: Event dictionary —Å metadata

    Returns:
        Formatted event string –¥–ª—è Telegram
    """
    metadata = event.get("metadata", {})
    subcategory = event.get("subcategory", "general")

    coins = metadata.get("coins", [])
    vote_count = metadata.get("vote_count", 0)
    categories = metadata.get("categories", [])
    proof = metadata.get("proof", "")

    # Subcategory icons
    subcategory_icons = {
        "mainnet": "üöÄ",
        "airdrop": "üí∏",
        "listing": "üìà",
        "token_unlock": "üîì",
        "hard_fork": "‚ö°",
        "protocol_upgrade": "üîß",
        "dao": "üèõÔ∏è",
        "nft": "üñºÔ∏è",
        "defi": "üè¶",
    }
    icon = subcategory_icons.get(subcategory, "ü™ô")

    lines = [
        f"{icon} <b>{escape(event.get('title', ''))}</b>",
        f"üìÖ {_fmt_dt(event.get('starts_at'))}",
    ]

    if coins:
        coins_text = ", ".join(coins[:3])
        if len(coins) > 3:
            coins_text += f" +{len(coins) - 3} more"
        lines.append(f"üí∞ Coins: {escape(coins_text)}")

    if vote_count > 0:
        lines.append(f"üë• Votes: {vote_count:,}")

    if categories:
        cats_text = ", ".join(categories[:3])
        lines.append(f"üè∑Ô∏è {escape(cats_text)}")

    if proof:
        lines.append(f'üîó <a href="{escape(proof)}">Proof</a>')

    return "\n".join(lines)


def format_event_markets(event: dict) -> str:
    """
    –§–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ —Ä—ã–Ω–æ—á–Ω—ã—Ö/—ç–∫–æ–Ω–æ–º–∏—á–µ—Å–∫–∏—Ö —Å–æ–±—ã—Ç–∏–π.

    Args:
        event: Event dictionary —Å metadata

    Returns:
        Formatted event string –¥–ª—è Telegram
    """
    metadata = event.get("metadata", {})

    country = event.get("location", "")
    country_code = metadata.get("country_code", "")
    fact = metadata.get("fact", event.get("fact", "‚Äî"))
    forecast = metadata.get("forecast", event.get("forecast", "‚Äî"))
    previous = metadata.get("previous", event.get("previous", "‚Äî"))

    # Country flag
    flag = country_flag(country_code) if country_code else ""

    lines = [
        f"üìà <b>{escape(event.get('title', ''))}</b>",
    ]

    if flag and country:
        lines.append(f"{flag} {escape(country)}")
    elif country:
        lines.append(f"üåç {escape(country)}")

    lines.append(f"üìÖ {_fmt_dt(event.get('starts_at'))}")

    # Metrics (—Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –Ω–µ "‚Äî")
    if fact != "‚Äî" or forecast != "‚Äî" or previous != "‚Äî":
        lines.append(
            f"üìä –§–∞–∫—Ç: {escape(str(fact))} ¬∑ " f"–ü—Ä–æ–≥–Ω–æ–∑: {escape(str(forecast))} ¬∑ " f"–ü—Ä–µ–¥.: {escape(str(previous))}"
        )

    return "\n".join(lines)


def format_event_tech(event: dict) -> str:
    """
    –§–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ —Ç–µ—Ö–Ω–æ–ª–æ–≥–∏—á–µ—Å–∫–∏—Ö —Å–æ–±—ã—Ç–∏–π.

    Args:
        event: Event dictionary —Å metadata

    Returns:
        Formatted event string –¥–ª—è Telegram
    """
    metadata = event.get("metadata", {})
    subcategory = event.get("subcategory", "general")

    # Software releases
    if subcategory == "software_release":
        version = metadata.get("version", "")
        project = metadata.get("project", "")
        link = event.get("link", "")

        title_text = event.get("title", "")
        if project and version:
            project_text = f"{project} v{version}"
        elif project:
            project_text = project
        else:
            project_text = ""

        lines = [
            f"üíª <b>{escape(title_text)}</b>",
        ]

        if project_text:
            lines.append(f"üì¶ {escape(project_text)}")

        lines.append(f"üìÖ {_fmt_dt(event.get('starts_at'))}")

        if link:
            lines.append(f'üîó <a href="{escape(link)}">Link</a>')

        return "\n".join(lines)

    # Conferences
    elif subcategory == "conference":
        location = event.get("location", "")
        organizer = event.get("organizer", "")

        lines = [
            f"üé§ <b>{escape(event.get('title', ''))}</b>",
        ]

        if location:
            lines.append(f"üìç {escape(location)}")

        lines.append(f"üìÖ {_fmt_dt(event.get('starts_at'))}")

        if organizer:
            lines.append(f"üèõÔ∏è {escape(organizer)}")

        return "\n".join(lines)

    # General tech events
    else:
        lines = [
            f"üíª <b>{escape(event.get('title', ''))}</b>",
            f"üìÖ {_fmt_dt(event.get('starts_at'))}",
        ]

        if event.get("description"):
            desc = _short(event.get("description", ""), 150)
            lines.append(f"üìù {escape(desc)}")

        return "\n".join(lines)


def format_event_world(event: dict) -> str:
    """
    –§–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –º–∏—Ä–æ–≤—ã—Ö —Å–æ–±—ã—Ç–∏–π (–ø–æ–ª–∏—Ç–∏–∫–∞, –∫–ª–∏–º–∞—Ç, –û–û–ù).

    Args:
        event: Event dictionary —Å metadata

    Returns:
        Formatted event string –¥–ª—è Telegram
    """
    location = event.get("location", "")
    organizer = event.get("organizer", "")

    lines = [
        f"üåç <b>{escape(event.get('title', ''))}</b>",
    ]

    if location:
        lines.append(f"üìç {escape(location)}")

    lines.append(f"üìÖ {_fmt_dt(event.get('starts_at'))}")

    if organizer:
        lines.append(f"üèõÔ∏è {escape(organizer)}")

    if event.get("description"):
        desc = _short(event.get("description", ""), 150)
        lines.append(f"üìã {escape(desc)}")

    return "\n".join(lines)


def format_event_generic(event: dict) -> str:
    """
    –û–±—â–∏–π —Ñ–æ—Ä–º–∞—Ç—Ç–µ—Ä –¥–ª—è —Å–æ–±—ã—Ç–∏–π –±–µ–∑ —Å–ø–µ—Ü–∏—Ñ–∏—á–µ—Å–∫–æ–π –∫–∞—Ç–µ–≥–æ—Ä–∏–∏.

    Args:
        event: Event dictionary

    Returns:
        Formatted event string –¥–ª—è Telegram
    """
    lines = [
        f"üìÖ <b>{escape(event.get('title', ''))}</b>",
        f"üïê {_fmt_dt(event.get('starts_at'))}",
    ]

    if event.get("location"):
        lines.append(f"üìç {escape(event.get('location', ''))}")

    return "\n".join(lines)


# -------- AI-–¥–∞–π–¥–∂–µ—Å—Ç --------


def format_digest_ai(summary: str, news: list[dict] | None = None, limit: int = 5) -> str:
    """
    –¢–µ–∫—Å—Ç AI-–¥–∞–π–¥–∂–µ—Å—Ç–∞ + –∫–æ—Ä–æ—Ç–∫–∏–π —Å–ø–∏—Å–æ–∫ —Å—Å—ã–ª–æ–∫.
    """
    if not summary:
        return "üì≠ No AI summary"

    lines = ["ü§ñ <b>AI digest</b>", "", escape(summary.strip())]

    if news:
        lines.append("")
        lines.append("üîó <b>Links:</b>")
        for i, item in enumerate(news[:limit], start=1):
            title_raw = (item.get("title") or item.get("source") or "Untitled").strip()
            title = escape(title_raw)
            link = escape(item.get("link") or "")
            lines.append(f'{i}. <a href="{link}">{title}</a>')

    return _clamp_tg("\n".join(lines))
